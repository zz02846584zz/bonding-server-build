"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = exports.Types = exports.toAsyncFunction = exports.merge = exports.generateRandomId = exports.getParamNames = exports.sleep = exports.isNullOrUndefined = exports.isNull = exports.isUndefined = exports.isRegExp = exports.isSet = exports.isMap = exports.isProxy = exports.isNumber = exports.isPlainObject = exports.isObject = exports.isFunction = exports.isPromise = exports.isGeneratorFunction = exports.isAsyncFunction = exports.isClass = exports.isString = void 0;
const util = require("util");
const crypto = require("crypto");
const camelCase_1 = require("./camelCase");
const uuid_1 = require("./uuid");
const flatted_1 = require("./flatted");
const ToString = Function.prototype.toString;
const hasOwn = Object.prototype.hasOwnProperty;
const toStr = Object.prototype.toString;
function fnBody(fn) {
    return ToString.call(fn)
        .replace(/^[^{]*{\s*/, '')
        .replace(/\s*}[^}]*$/, '');
}
function isString(value) {
    return typeof value === 'string';
}
exports.isString = isString;
function isClass(fn) {
    if (typeof fn !== 'function') {
        return false;
    }
    if (/^class[\s{]/.test(ToString.call(fn))) {
        return true;
    }
    // babel.js classCallCheck() & inlined
    const body = fnBody(fn);
    return (/classCallCheck\(/.test(body) ||
        /TypeError\("Cannot call a class as a function"\)/.test(body));
}
exports.isClass = isClass;
function isAsyncFunction(value) {
    return util.types.isAsyncFunction(value);
}
exports.isAsyncFunction = isAsyncFunction;
function isGeneratorFunction(value) {
    return util.types.isGeneratorFunction(value);
}
exports.isGeneratorFunction = isGeneratorFunction;
function isPromise(value) {
    return util.types.isPromise(value);
}
exports.isPromise = isPromise;
function isFunction(value) {
    return typeof value === 'function';
}
exports.isFunction = isFunction;
function isObject(value) {
    return value !== null && typeof value === 'object';
}
exports.isObject = isObject;
function isPlainObject(obj) {
    if (!obj || toStr.call(obj) !== '[object Object]') {
        return false;
    }
    const hasOwnConstructor = hasOwn.call(obj, 'constructor');
    const hasIsPrototypeOf = obj.constructor &&
        obj.constructor.prototype &&
        hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    // Not own constructor property must be Object
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
    }
    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    let key;
    for (key in obj) {
        /**/
    }
    return typeof key === 'undefined' || hasOwn.call(obj, key);
}
exports.isPlainObject = isPlainObject;
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
function isProxy(value) {
    return util.types.isProxy(value);
}
exports.isProxy = isProxy;
function isMap(value) {
    return util.types.isMap(value);
}
exports.isMap = isMap;
function isSet(value) {
    return util.types.isSet(value);
}
exports.isSet = isSet;
function isRegExp(value) {
    return util.types.isRegExp(value);
}
exports.isRegExp = isRegExp;
function isUndefined(value) {
    return value === undefined;
}
exports.isUndefined = isUndefined;
function isNull(value) {
    return value === null;
}
exports.isNull = isNull;
function isNullOrUndefined(value) {
    return isUndefined(value) || isNull(value);
}
exports.isNullOrUndefined = isNullOrUndefined;
function sleep(sleepTime = 1000) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, sleepTime);
    });
}
exports.sleep = sleep;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
/**
 * get parameter name from function
 * @param func
 */
function getParamNames(func) {
    const fnStr = func.toString().replace(STRIP_COMMENTS, '');
    let result = fnStr
        .slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'))
        .split(',')
        .map(content => {
        return content.trim().replace(/\s?=.*$/, '');
    });
    if (result.length === 1 && result[0] === '') {
        result = [];
    }
    return result;
}
exports.getParamNames = getParamNames;
/**
 * generate a lightweight 32 bit random id, enough for ioc container
 */
function generateRandomId() {
    // => f9b327e70bbcf42494ccb28b2d98e00e
    return crypto.randomBytes(16).toString('hex');
}
exports.generateRandomId = generateRandomId;
function merge(target, src) {
    if (!target) {
        target = src;
        src = null;
    }
    if (!target) {
        return null;
    }
    if (Array.isArray(target)) {
        return target.concat(src || []);
    }
    if (typeof target === 'object') {
        return Object.assign({}, target, src);
    }
    throw new Error('can not merge meta that type of ' + typeof target);
}
exports.merge = merge;
function toAsyncFunction(method) {
    if (isAsyncFunction(method)) {
        return method;
    }
    else {
        return async function (...args) {
            return Promise.resolve(method.call(this, ...args));
        };
    }
}
exports.toAsyncFunction = toAsyncFunction;
exports.Types = {
    isClass,
    isAsyncFunction,
    isGeneratorFunction,
    isString,
    isPromise,
    isFunction,
    isObject,
    isPlainObject,
    isNumber,
    isProxy,
    isMap,
    isSet,
    isRegExp,
    isUndefined,
    isNull,
    isNullOrUndefined,
};
exports.Utils = {
    sleep,
    getParamNames,
    generateRandomId,
    merge,
    camelCase: camelCase_1.camelCase,
    pascalCase: camelCase_1.pascalCase,
    randomUUID: uuid_1.randomUUID,
    toAsyncFunction,
    safeStringify: flatted_1.safeStringify,
    safeParse: flatted_1.safeParse,
};
//# sourceMappingURL=index.js.map