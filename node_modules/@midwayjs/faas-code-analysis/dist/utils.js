"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyStaticFiles = exports.innerTsConfigMaker = exports.copyFiles = exports.compareFileChange = exports.getEventKey = exports.formatUpperCamel = exports.firstCharLower = void 0;
const globby = require("globby");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const os_1 = require("os");
const plimit = require("p-limit");
// 首字母小写
const firstCharLower = str => {
    return str.replace(/^[A-Z]/g, match => match.toLowerCase());
};
exports.firstCharLower = firstCharLower;
// 驼峰变为 -
const formatUpperCamel = str => {
    return (0, exports.firstCharLower)(str).replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
};
exports.formatUpperCamel = formatUpperCamel;
const getEventKey = (type, event) => {
    if (type === 'http') {
        return `${event.method || ''}:${event.path || ''}`;
    }
    return type;
};
exports.getEventKey = getEventKey;
// 符合sourceGlob条件的文件中 是否存在 比所有符合toGlob条件的文件 要新的文件
// 返回 fromGlob 中更新的文件
const compareFileChange = async (fromGlob, toGlob, options) => {
    options = options || {};
    if (!options.cwd) {
        options.cwd = process.cwd();
    }
    options.stats = true;
    const isWindows = (0, os_1.platform)() === 'win32';
    if (isWindows) {
        fromGlob = fromGlob.map(pattern => {
            return pattern.replace(/\\+/g, '/');
        });
        toGlob = toGlob.map(pattern => {
            return pattern.replace(/\\+/g, '/');
        });
    }
    const fromFiles = await globby(fromGlob, options);
    const toFiles = await globby(toGlob, options);
    if (!fromFiles || !fromFiles.length) {
        return [];
    }
    if (!toFiles || !toFiles.length) {
        return fromFiles.map((file) => file.path);
    }
    let latestFilesChangeTime = 0;
    for (const file of toFiles) {
        if (file.stats.mtimeMs > latestFilesChangeTime) {
            latestFilesChangeTime = file.stats.mtimeMs;
        }
    }
    const result = [];
    for (const file of fromFiles) {
        if (file.stats.mtimeMs > latestFilesChangeTime) {
            result.push(file.path);
        }
    }
    return result;
};
exports.compareFileChange = compareFileChange;
const copyFiles = async (options) => {
    const { defaultInclude, include, exclude, sourceDir, targetDir, log } = options;
    const paths = await globby((defaultInclude || ['*.yml', '*.js', '*.ts', '*.json', 'app', 'config']).concat(include || []), {
        cwd: sourceDir,
        followSymbolicLinks: false,
        ignore: [
            '**/node_modules/**',
            '**/test/**',
            '**/run/**',
            '**/.serverless/**',
            '**/.faas_debug_tmp/**', // faas 调试临时目录
        ].concat(exclude || []),
    });
    await docopy(sourceDir, targetDir, paths, log);
};
exports.copyFiles = copyFiles;
const innerTsConfigMaker = (options) => {
    return {
        compileOnSave: true,
        compilerOptions: {
            incremental: options.incremental,
            target: 'ES2018',
            module: 'commonjs',
            moduleResolution: 'node',
            experimentalDecorators: true,
            emitDecoratorMetadata: true,
            inlineSourceMap: true,
            noImplicitThis: true,
            noUnusedLocals: true,
            stripInternal: true,
            pretty: true,
            declaration: true,
            jsx: 'react',
            outDir: options.outDir,
        },
        include: options.include || [],
        exclude: options.exclude || [],
    };
};
exports.innerTsConfigMaker = innerTsConfigMaker;
const copyStaticFiles = async ({ sourceDir, targetDir, log }) => {
    if (!sourceDir || !targetDir) {
        return;
    }
    const paths = globby.sync(['**/*.*'], {
        cwd: sourceDir,
        followSymbolicLinks: false,
        ignore: [
            '**/*.ts',
            '**/node_modules/**', // 模块依赖目录
        ],
    });
    return docopy(sourceDir, targetDir, paths, log);
};
exports.copyStaticFiles = copyStaticFiles;
const docopy = async (sourceDir, targetDir, paths, log) => {
    const limit = plimit(20);
    await Promise.all(paths.map((path) => {
        const source = (0, path_1.join)(sourceDir, path);
        const target = (0, path_1.join)(targetDir, path);
        if ((0, fs_extra_1.existsSync)(target)) {
            const sourceStat = (0, fs_extra_1.statSync)(source);
            const targetStat = (0, fs_extra_1.statSync)(target);
            // source 修改时间小于目标文件 修改时间，则不拷贝
            if (sourceStat.mtimeMs <= targetStat.mtimeMs) {
                return;
            }
        }
        if (log) {
            log(path);
        }
        return limit(() => {
            return new Promise(resolve => {
                (0, fs_extra_1.copy)(source, target)
                    .then(resolve)
                    .catch(e => {
                    if (log) {
                        log(`Error!!! From '${source}' to '${target}'`, e);
                    }
                    resolve(void 0);
                });
            });
        });
    }));
};
//# sourceMappingURL=utils.js.map