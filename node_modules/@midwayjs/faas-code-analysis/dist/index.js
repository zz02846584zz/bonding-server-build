"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analysisResultToSpec = exports.analysis = void 0;
const mwcc_1 = require("@midwayjs/mwcc");
const utils_1 = require("./utils");
__exportStar(require("./interface"), exports);
__exportStar(require("./utils"), exports);
const analysis = async (codePath) => {
    if (Array.isArray(codePath)) {
        codePath = codePath[0];
        console.log('[warn] code analysi only support 1 source dir');
    }
    const analysisInstance = new mwcc_1.Analyzer({
        projectDir: codePath,
        decoratorLowerCase: true,
    });
    const analysisResult = analysisInstance.analyze();
    return (0, exports.analysisResultToSpec)(analysisResult);
};
exports.analysis = analysis;
const analysisResultToSpec = (analysisResult) => {
    var _a, _b;
    const result = {
        functions: {},
    };
    const provideList = ((_a = analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.decorator) === null || _a === void 0 ? void 0 : _a.provide) || [];
    provideList.forEach(provide => {
        var _a;
        if (!((_a = provide === null || provide === void 0 ? void 0 : provide.childDecorators) === null || _a === void 0 ? void 0 : _a.func)) {
            return;
        }
        provide.childDecorators.func.forEach(item => {
            formatFuncInfo(result, item, provide.target);
        });
    });
    const funcList = ((_b = analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.decorator) === null || _b === void 0 ? void 0 : _b.func) || [];
    funcList.forEach(item => {
        if (item.target.type !== 'class') {
            return;
        }
        formatFuncInfo(result, item);
    });
    return result;
};
exports.analysisResultToSpec = analysisResultToSpec;
const formatFuncInfo = (result, funcInfo, parentTarget) => {
    const params = funcInfo.params;
    let className = (parentTarget === null || parentTarget === void 0 ? void 0 : parentTarget.name) || '';
    let funcName = funcInfo.target.name || 'handler';
    if (funcInfo.target.type === 'class') {
        className = funcInfo.target.name;
        funcName = 'handler';
    }
    let handler;
    let trigger;
    if (typeof params[0] === 'string') {
        handler = params[0];
        trigger = params[1];
    }
    else {
        handler = `${(0, utils_1.formatUpperCamel)(className)}.${(0, utils_1.formatUpperCamel)(funcName)}`;
        trigger = params[0];
    }
    const funName = handler.replace(/\.handler$/, '').replace(/\./g, '-');
    const existsFuncData = result.functions[funName] || {};
    existsFuncData.handler = handler;
    const events = existsFuncData.events || [];
    if (!trigger) {
        trigger = {
            event: 'http',
        };
    }
    if (trigger.event) {
        const eventType = trigger.event.toLowerCase();
        const event = { [eventType]: true };
        if (eventType === 'http') {
            event.http = {
                method: [(trigger.method || 'GET').toUpperCase()],
                path: trigger.path ||
                    `/${(0, utils_1.firstCharLower)(className)}/${(0, utils_1.firstCharLower)(funcName)}`,
            };
        }
        // 防止有重复的触发器
        const currentEventKey = (0, utils_1.getEventKey)(eventType, event[eventType]);
        const isExists = events.find(event => {
            if (event[eventType]) {
                const key = (0, utils_1.getEventKey)(eventType, event[eventType]);
                return key === currentEventKey;
            }
        });
        if (!isExists) {
            events.push(event);
        }
    }
    existsFuncData.events = events;
    result.functions[funName] = existsFuncData;
};
//# sourceMappingURL=index.js.map