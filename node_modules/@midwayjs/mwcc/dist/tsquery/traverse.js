"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visit = exports.traverse = void 0;
const typescript_1 = __importDefault(require("typescript"));
function traverse(node, visitor, ancestor) {
    var _a, _b;
    if (node == null) {
        return;
    }
    (_a = visitor.enter) === null || _a === void 0 ? void 0 : _a.call(visitor, node, ancestor);
    typescript_1.default.forEachChild(node, child => {
        traverse(child, visitor, node);
    });
    (_b = visitor.leave) === null || _b === void 0 ? void 0 : _b.call(visitor, node);
}
exports.traverse = traverse;
function visit(node, visitor, ctx, ancestor) {
    var _a, _b, _c;
    const before = (_a = visitor.enter) === null || _a === void 0 ? void 0 : _a.call(visitor, node, ancestor);
    // this `node` and its children may be a synthetic node that doesn't have a `parent` set.
    if (before && before.parent == null && ancestor) {
        setParent(before, node.parent);
    }
    if (before) {
        /**
         * transformer may fall into infinite loop if revisit their result nodes.
         */
        return before;
    }
    let result = typescript_1.default.visitEachChild(node, child => {
        return visit(child, visitor, ctx, node);
    }, ctx);
    result = (_c = (_b = visitor.leave) === null || _b === void 0 ? void 0 : _b.call(visitor, node)) !== null && _c !== void 0 ? _c : result;
    // this `node` and its children may be a synthetic node that doesn't have a `parent` set.
    if (result && result.parent == null && ancestor) {
        setParent(result, node.parent);
    }
    return result;
}
exports.visit = visit;
function setParent(_node, ancestor) {
    const node = _node;
    node.parent = ancestor;
    typescript_1.default.forEachChild(node, child => {
        setParent(child, node);
    });
}
//# sourceMappingURL=traverse.js.map