"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Program = void 0;
const typescript_1 = __importDefault(require("typescript"));
const transformer_1 = __importDefault(require("./transformation/transformer"));
const util_1 = require("./util");
const path_1 = __importDefault(require("path"));
class Program {
    constructor(host, files) {
        this.host = host;
        /** @internal */
        this.reportDiagnostic = (diagnostic) => {
            if (diagnostic.file) {
                const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
                const message = typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                console.log(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);
            }
            else {
                console.log(typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n'));
            }
        };
        const compilerOptions = host.getCompilerOptions();
        const projectDir = host.getProjectDir();
        const parsedCommandLine = host.parsedCommandLine;
        const derivedOutputDir = host.derivedOutputDir;
        files = files !== null && files !== void 0 ? files : host.getProjectFiles();
        const context = (this.context = {
            config: this.host.getMwccConfig(),
            files,
            outFiles: [],
            projectDir,
            derivedOutputDir,
            buildDir: host.compilerOptions.outDir,
            getTsOutputPath(filename) {
                if (path_1.default.isAbsolute(filename) && !filename.startsWith(projectDir)) {
                    return;
                }
                const files = typescript_1.default
                    .getOutputFileNames(parsedCommandLine, filename, true)
                    .filter(it => it.endsWith('.js'));
                if (files.length === 0) {
                    return;
                }
                util_1.assert(files.length === 1);
                const expectedOutputFile = files[0];
                const relPath = path_1.default.relative(derivedOutputDir, expectedOutputFile);
                const basename = path_1.default.basename(relPath);
                return path_1.default.join(context.buildDir, path_1.default.dirname(relPath), basename);
            },
        });
        if (compilerOptions.incremental) {
            this.builderProgram = typescript_1.default.createIncrementalProgram({
                rootNames: files,
                host: host.compilerHost,
                options: compilerOptions,
            });
            this.program = this.builderProgram.getProgram();
        }
        else {
            this.program = typescript_1.default.createProgram(files, compilerOptions, host.compilerHost);
        }
    }
    getTypeChecker() {
        return this.program.getTypeChecker();
    }
    getSourceFiles() {
        return this.program.getSourceFiles();
    }
    getSourceFile(filename) {
        return this.program.getSourceFile(filename);
    }
    async emit() {
        var _a;
        let allDiagnostics = [];
        const emitResult = this.program.emit(undefined, undefined, undefined, false, {
            before: [
                transformer_1.default(this.host.compilerHost, this.getTypeChecker(), this.host.getMwccConfig()),
            ],
        });
        this.context.outFiles = (_a = emitResult.emittedFiles) !== null && _a !== void 0 ? _a : [];
        this.calibrateSourceRoots(this.host.compilerHost);
        allDiagnostics = typescript_1.default
            .getPreEmitDiagnostics(this.program)
            .concat(emitResult.diagnostics);
        const reporter = this.getDiagnosticReporter();
        typescript_1.default.sortAndDeduplicateDiagnostics(allDiagnostics).forEach(reporter);
        /**
         * -1. finalize output files
         */
        this.finalizeFileSystem(this.host.compilerHost);
        const summary = this.generateBuildSummary();
        typescript_1.default.sys.writeFile(path_1.default.join(this.context.derivedOutputDir, 'midway.build.json'), JSON.stringify(summary, null, 2));
        return { summary, diagnostics: allDiagnostics };
    }
    emitFile(fileName) {
        const output = { code: '', map: '', declaration: '' };
        if (!path_1.default.isAbsolute(fileName)) {
            fileName = path_1.default.join(this.context.projectDir, fileName);
        }
        const sourceFile = this.program.getSourceFile(fileName);
        if (sourceFile == null) {
            throw new Error(`file not found in project: ${fileName}`);
        }
        this.program.emit(sourceFile, (path, file) => {
            if (path.endsWith('.map')) {
                output.map = file;
            }
            else if (path.endsWith('.d.ts')) {
                output.declaration = file;
            }
            else {
                output.code = file;
            }
        }, undefined, false, {
            before: [
                transformer_1.default(this.host.compilerHost, this.getTypeChecker(), this.host.getMwccConfig()),
            ],
        });
        return output;
    }
    /** @internal */
    getDiagnosticReporter() {
        if (typescript_1.default.createDiagnosticReporter) {
            return typescript_1.default.createDiagnosticReporter(typescript_1.default.sys, true);
        }
        return this.reportDiagnostic;
    }
    /** @internal */
    finalizeFileSystem(host) {
        for (const file of this.context.outFiles) {
            const content = host.readFile(file);
            if (content == null) {
                continue;
            }
            const filename = path_1.default.resolve(this.context.derivedOutputDir, path_1.default.relative(this.context.buildDir, file));
            host.writeFile(filename, content, false);
        }
        this.context.outFiles = this.context.outFiles.map(it => {
            return path_1.default.resolve(this.context.derivedOutputDir, path_1.default.relative(this.context.buildDir, it));
        });
    }
    /** @internal */
    generateBuildSummary() {
        return {
            ...this.context.config,
            build: {
                inputFiles: this.context.files,
                outputFiles: this.context.outFiles,
            },
            versions: {
                mwcc: require('../package.json').version,
                typescript: require(require.resolve('typescript/package.json')).version,
            },
        };
    }
    /**
     * @internal
     * Refer to issue https://github.com/microsoft/TypeScript/issues/31873 for more info
     */
    calibrateSourceRoots(host) {
        const sourceRoot = this.host.parsedCommandLine.options.sourceRoot;
        if (sourceRoot == null || !sourceRoot) {
            return;
        }
        this.context.outFiles
            .filter(it => it.endsWith('.map'))
            .forEach(it => {
            const content = host.readFile(it);
            if (content == null) {
                return;
            }
            const json = util_1.safeJsonParse(content);
            if (json == null || json.sourceRoot == null) {
                return;
            }
            const calibratedRoot = path_1.default.join(path_1.default.relative(path_1.default.dirname(it), this.context.buildDir), sourceRoot);
            json.sourceRoot = calibratedRoot;
            host.writeFile(it, JSON.stringify(json), false);
        });
    }
}
exports.Program = Program;
//# sourceMappingURL=program.js.map