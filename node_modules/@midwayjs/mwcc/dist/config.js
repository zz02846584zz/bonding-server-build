"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveTsConfigFile = exports.mergeConfigs = exports.mergeCompilerOptions = exports.getDefaultConfig = void 0;
const ts = __importStar(require("typescript"));
const path = __importStar(require("path"));
const util_1 = require("./util");
function getDefaultConfig(projectDir, outDir = 'dist', sourceDir = 'src') {
    const absoluteRootDir = path.resolve(projectDir);
    const absoluteOutDir = path.resolve(absoluteRootDir, outDir);
    const absoluteSourceDir = path.resolve(absoluteRootDir, sourceDir);
    return {
        features: {
            tsc: true,
        },
        compilerOptions: {
            // language features
            target: 'es2018',
            module: 'commonjs',
            moduleResolution: 'node',
            jsx: 'react',
            allowJs: true,
            experimentalDecorators: true,
            emitDecoratorMetadata: true,
            // source maps
            sourceMap: true,
            inlineSourceMap: false,
            inlineSources: false,
            sourceRoot: path.relative(absoluteOutDir, absoluteSourceDir),
            // directories
            outDir: absoluteOutDir,
            rootDir: absoluteSourceDir,
            // program emit options
            listEmittedFiles: true,
        },
        include: [absoluteSourceDir],
        exclude: ['**/node_modules'],
    };
}
exports.getDefaultConfig = getDefaultConfig;
function mergeCompilerOptions(base, target, projectDir) {
    var _a;
    const compilerOptions = util_1.extend(base, target);
    /**
     * calibrate source root and source map and output dir
     */
    if ((target === null || target === void 0 ? void 0 : target.rootDir) || (target === null || target === void 0 ? void 0 : target.outDir)) {
        const absoluteOutDir = (target === null || target === void 0 ? void 0 : target.outDir)
            ? path.resolve(projectDir, target.outDir)
            : base.outDir;
        const absoluteRootDir = (target === null || target === void 0 ? void 0 : target.rootDir)
            ? path.resolve(projectDir, target.rootDir)
            : base.rootDir;
        compilerOptions.outDir = absoluteOutDir;
        compilerOptions.rootDir = absoluteRootDir;
        if (((_a = target === null || target === void 0 ? void 0 : target.compilerOptions) === null || _a === void 0 ? void 0 : _a.sourceRoot) == null) {
            compilerOptions.sourceRoot = path.relative(absoluteOutDir, absoluteRootDir);
        }
    }
    if (target === null || target === void 0 ? void 0 : target.inlineSourceMap) {
        delete compilerOptions.sourceMap;
    }
    [
        'out',
        'outFile',
        'rootDirs',
        ['noEmit', false],
        ['module', 'commonjs'],
        ['importHelpers', false],
        ['emitBOM', false],
        ['listEmittedFiles', true],
        ['experimentalDecorators', true],
        ['emitDecoratorMetadata', true],
    ].forEach(key => {
        if (Array.isArray(key)) {
            overrideCompilerOptions(target, compilerOptions, key[0], key[1]);
        }
        else {
            overrideCompilerOptions(target, compilerOptions, key);
        }
    });
    if (compilerOptions.incremental && compilerOptions.tsBuildInfoFile == null) {
        compilerOptions.tsBuildInfoFile = path.join(compilerOptions.outDir, '.tsbuildinfo');
    }
    return compilerOptions;
}
exports.mergeCompilerOptions = mergeCompilerOptions;
function mergeConfigs(base, target, projectDir) {
    var _a, _b, _c;
    const compilerOptions = mergeCompilerOptions(base.compilerOptions, target === null || target === void 0 ? void 0 : target.compilerOptions, projectDir);
    let include = new Set(base.include);
    if (target === null || target === void 0 ? void 0 : target.include) {
        include = new Set([...target.include]);
    }
    if (((_a = target === null || target === void 0 ? void 0 : target.compilerOptions) === null || _a === void 0 ? void 0 : _a.rootDir) &&
        (target === null || target === void 0 ? void 0 : target.compilerOptions.rootDir) !== ((_b = base.compilerOptions) === null || _b === void 0 ? void 0 : _b.rootDir)) {
        include.delete((_c = base.compilerOptions) === null || _c === void 0 ? void 0 : _c.rootDir);
        include.add(compilerOptions.rootDir);
    }
    const features = util_1.extend(base.features, target === null || target === void 0 ? void 0 : target.features);
    return util_1.extend(base, target, {
        compilerOptions,
        include: [...include],
        features,
    });
}
exports.mergeConfigs = mergeConfigs;
function resolveTsConfigFile(projectDir, outDir, configName, hintConfig, overrideConfig) {
    let tsconfigPath = ts.findConfigFile(projectDir, ts.sys.fileExists, configName);
    let readConfig;
    if ((tsconfigPath === null || tsconfigPath === void 0 ? void 0 : tsconfigPath.startsWith(util_1.toUnix(projectDir))) === false) {
        tsconfigPath = undefined;
    }
    if (tsconfigPath != null) {
        const readResult = ts.readConfigFile(tsconfigPath, ts.sys.readFile);
        if (readResult.error) {
            throw new Error(`Failed to parse ${tsconfigPath} for ${readResult.error.messageText}`);
        }
        readConfig = readResult.config;
    }
    const defaultConfig = getDefaultConfig(projectDir, outDir);
    let config = mergeConfigs(defaultConfig, hintConfig, projectDir);
    config = mergeConfigs(config, readConfig, projectDir);
    config = mergeConfigs(config, { compilerOptions: { outDir } }, projectDir);
    config = mergeConfigs(config, overrideConfig, projectDir);
    return { config, tsconfigPath };
}
exports.resolveTsConfigFile = resolveTsConfigFile;
function overrideCompilerOptions(target, compilerOptions, key, val) {
    if ((target === null || target === void 0 ? void 0 : target[key]) == null) {
        return;
    }
    if (typeof target[key] !== 'string' && target[key] === val) {
        return;
    }
    if (typeof target[key] === 'string' && target[key].toLowerCase() === val) {
        return;
    }
    util_1.debug(`override compilerOptions.${key} with ${JSON.stringify(val)}`);
    if (val == null) {
        delete compilerOptions[key];
    }
    else {
        compilerOptions[key] = val;
    }
}
//# sourceMappingURL=config.js.map