"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseConfiguration = void 0;
const tsquery_1 = require("../tsquery");
const util_1 = require("../util");
const typescript_1 = __importDefault(require("typescript"));
const module_1 = require("./module");
function parseConfiguration(program) {
    const fileNames = program.getRootFileNames();
    const result = {
        imports: [],
        configs: [],
    };
    for (const fileName of fileNames) {
        const sourceFile = program.getSourceFile(fileName);
        const config = parseConfigurationInFile(sourceFile, program);
        result.imports = result.imports.concat(config.imports);
        result.configs = result.configs.concat(config.configs);
    }
    return result;
}
exports.parseConfiguration = parseConfiguration;
function parseConfigurationInFile(sourceFile, program) {
    if (sourceFile.fileName.endsWith('.js')) {
        return parseConfigurationInJS(sourceFile, program);
    }
    const decorators = tsquery_1.query(sourceFile, 'ClassDeclaration Decorator');
    const result = {
        imports: [],
        configs: [],
    };
    for (const decorator of decorators) {
        const config = resolveDecoratorCallExpression(decorator.expression, program);
        if (config) {
            result.imports = result.imports.concat(config.imports);
            result.configs = result.configs.concat(config.configs);
        }
    }
    return result;
}
function parseConfigurationInJS(sourceFile, program) {
    const decorations = tsquery_1.query(sourceFile, 'CallExpression[expression.escapedText="___decorate"]');
    const result = {
        imports: [],
        configs: [],
    };
    for (const decoration of decorations) {
        if (!typescript_1.default.isCallExpression(decoration)) {
            continue;
        }
        const arg = decoration.arguments[0];
        if (!typescript_1.default.isArrayLiteralExpression(arg)) {
            continue;
        }
        for (const decoratorExpression of arg.elements) {
            const config = resolveDecoratorCallExpression(decoratorExpression, program);
            if (config) {
                result.imports = result.imports.concat(config.imports);
                result.configs = result.configs.concat(config.configs);
            }
        }
    }
    return result;
}
function resolveDecoratorCallExpression(expression, program) {
    if (!typescript_1.default.isCallExpression(expression)) {
        return;
    }
    const arg = expression.arguments[0];
    if (!typescript_1.default.isObjectLiteralExpression(arg)) {
        return;
    }
    if (typescript_1.default.isIdentifier(expression.expression)) {
        const symbol = program
            .getTypeChecker()
            .getSymbolAtLocation(expression.expression);
        if (util_1.any(module_1.resolveImportedName(symbol), isMidwayJsConfigurationDecorator)) {
            const config = resolveConfiguration(arg);
            return config;
        }
    }
    if (typescript_1.default.isPropertyAccessExpression(expression.expression)) {
        const expr = expression.expression;
        if (!typescript_1.default.isIdentifier(expr.expression) || !typescript_1.default.isIdentifier(expr.name)) {
            return;
        }
        const symbol = program
            .getTypeChecker()
            .getSymbolAtLocation(expr.expression);
        if (util_1.any(module_1.resolveImportedName(symbol), mod => isMidwayJsConfigurationDecorator(mod, expr.name.escapedText))) {
            const config = resolveConfiguration(arg);
            return config;
        }
    }
    return undefined;
}
function isMidwayJsConfigurationDecorator(mod, accessName) {
    if (mod.moduleId !== '@midwayjs/decorator') {
        return false;
    }
    const exportedName = accessName !== null && accessName !== void 0 ? accessName : mod.exportedName;
    if (exportedName === 'Configuration') {
        return true;
    }
    return false;
}
function resolveConfiguration(node) {
    const configuration = {
        imports: [],
        configs: [],
    };
    for (const prop of node.properties) {
        if (!typescript_1.default.isPropertyAssignment(prop)) {
            continue;
        }
        if (!typescript_1.default.isIdentifier(prop.name)) {
            continue;
        }
        if (prop.name.escapedText === 'imports' &&
            typescript_1.default.isArrayLiteralExpression(prop.initializer)) {
            configuration.imports = castArrayLiteralExpressionToStringArray(prop.initializer).map(it => ({ moduleId: it }));
        }
        if (prop.name.escapedText === 'configs' &&
            typescript_1.default.isArrayLiteralExpression(prop.initializer)) {
            configuration.configs = castArrayLiteralExpressionToStringArray(prop.initializer);
        }
    }
    return configuration;
}
function castArrayLiteralExpressionToStringArray(literal) {
    return literal.elements
        .map(it => {
        if (!typescript_1.default.isStringLiteral(it)) {
            return;
        }
        return it.text;
    })
        .filter(it => !!it);
}
//# sourceMappingURL=configuration.js.map