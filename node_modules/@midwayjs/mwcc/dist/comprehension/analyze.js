"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Analyzer = void 0;
const typescript_1 = __importDefault(require("typescript"));
const compiler_host_1 = require("../compiler-host");
const program_1 = require("../program");
const tsquery_1 = require("../tsquery");
const expression_1 = require("./expression");
const node_1 = require("./node");
const util_1 = require("../util");
class Analyzer {
    constructor(options) {
        this.analyzeResult = {
            decorator: {},
            class: {},
        };
        this.options = options || {};
        this.program = this.initProgram(options);
        this.projectDir = util_1.toUnix(this.program.context.projectDir);
        this.checker = this.program.getTypeChecker();
    }
    analyze() {
        this.analyzeResult.class = this.getClasses();
        this.analyzeResult.decorator = this.getDecorators();
        return this.analyzeResult;
    }
    getProgram() {
        return this.program;
    }
    // program initialize
    initProgram(options) {
        const { program, compilerHost, projectDir, mwccConfig } = options;
        if (program) {
            return program;
        }
        else if (compilerHost) {
            return new program_1.Program(compilerHost);
        }
        else {
            return new program_1.Program(new compiler_host_1.CompilerHost(projectDir || process.cwd(), mwccConfig || {}));
        }
    }
    getClasses() {
        const classMap = {};
        for (const sourceFile of this.program.getSourceFiles()) {
            const classes = tsquery_1.query(sourceFile, 'ClassDeclaration');
            classes.forEach(classItem => {
                const classInfo = this.getClassInfo(classItem);
                if (!classInfo) {
                    return;
                }
                classMap[classInfo.id] = classInfo;
            });
        }
        return classMap;
    }
    getDecorators() {
        const decoratorsMap = {};
        const decoratorList = [];
        for (const sourceFile of this.program.getSourceFiles()) {
            const decorators = tsquery_1.query(sourceFile, 'ClassDeclaration Decorator');
            decorators.forEach((decorator) => {
                const decoratorInfo = this.analyzeDecorator(decorator);
                if (decoratorInfo) {
                    decoratorList.push(decoratorInfo);
                    this.assignDecorators(decoratorsMap, decoratorInfo);
                }
            });
        }
        for (const decorator of decoratorList) {
            if (decorator.target.type !== 'class') {
                const parents = this.findParent(decoratorList, decorator);
                if (parents === null || parents === void 0 ? void 0 : parents.length) {
                    for (const parent of parents) {
                        if (!parent.childDecorators) {
                            parent.childDecorators = {};
                        }
                        this.assignDecorators(parent.childDecorators, decorator);
                    }
                }
            }
        }
        return decoratorsMap;
    }
    // find the class where the decorator is decorating the target
    findParent(decorators, find) {
        const matchedDecorators = [];
        for (const decorator of decorators) {
            if (decorator.target.type === 'class' &&
                decorator.sourceFile === find.sourceFile &&
                decorator.target.position.range.start <=
                    find.target.position.range.start &&
                decorator.target.position.range.end >= find.target.position.range.end) {
                matchedDecorators.push(decorator);
            }
        }
        return matchedDecorators;
    }
    // get class info
    getClassInfo(classItem) {
        const sourceFile = classItem.getSourceFile();
        if (sourceFile.fileName.indexOf(this.projectDir) === -1) {
            return;
        }
        return node_1.getClassInfo(classItem);
    }
    analyzeDecorator(decorator) {
        if (!typescript_1.default.isCallExpression(decorator.expression)) {
            return;
        }
        const sourceFile = decorator.getSourceFile();
        const sourceInfo = {
            sourceFile: sourceFile.fileName,
        };
        const expressionInfo = expression_1.getExpressionBaseInfo(decorator.expression);
        if (!expressionInfo) {
            return;
        }
        let name = expressionInfo.expressionName;
        if (this.options.decoratorLowerCase) {
            name = name.toLowerCase();
        }
        const decoratorInfo = {
            name,
            sourceFile: sourceInfo.sourceFile,
            params: expressionInfo.params,
            position: expressionInfo.position,
            target: node_1.getNodeInfo(decorator.parent, this.analyzeResult.class),
        };
        return decoratorInfo;
    }
    assignDecorators(target, source) {
        if (!source || !target) {
            return;
        }
        const decoratorName = source.name;
        if (!target[decoratorName]) {
            target[decoratorName] = [];
        }
        target[decoratorName].push(source);
    }
}
exports.Analyzer = Analyzer;
//# sourceMappingURL=analyze.js.map