"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveImportedName = void 0;
const typescript_1 = __importDefault(require("typescript"));
function resolveImportedName(symbol) {
    var _a, _b, _c, _d;
    const results = [];
    for (const decl of symbol.declarations) {
        /**
         * One of:
         * - import { <foo> } from 'mod';
         * - import { <foo as bar> } from 'mod';
         */
        if (typescript_1.default.isImportSpecifier(decl)) {
            const importDecl = closestAncestor(decl, typescript_1.default.SyntaxKind.ImportDeclaration);
            if (importDecl == null) {
                continue;
            }
            const moduleId = resolveImportModuleId(importDecl);
            if (moduleId == null) {
                continue;
            }
            results.push({
                moduleId,
                exportedName: (_b = (_a = decl.propertyName) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : decl.name.getText(),
                importedName: decl.name.getText(),
            });
            continue;
        }
        /**
         * One of:
         * - import <foo> from 'mod';
         */
        if (typescript_1.default.isImportClause(decl)) {
            const importDecl = closestAncestor(decl, typescript_1.default.SyntaxKind.ImportDeclaration);
            if (importDecl == null) {
                continue;
            }
            const moduleId = resolveImportModuleId(importDecl);
            if (moduleId == null) {
                continue;
            }
            results.push({
                moduleId,
                importedName: decl.name.getText(),
            });
            continue;
        }
        /**
         * One of:
         * - <import foo = require('mod')>;
         */
        if (typescript_1.default.isImportEqualsDeclaration(decl)) {
            const moduleId = resolveImportModuleId(decl);
            if (moduleId == null) {
                continue;
            }
            results.push({
                moduleId,
                importedName: decl.name.getText(),
            });
            continue;
        }
        /**
         * One of:
         * - const <foo = require('mod')>;
         * - TODO: const <foo = require('mod').foo.bar>;
         */
        if (typescript_1.default.isVariableDeclaration(decl)) {
            const moduleId = resolveImportModuleId(decl);
            if (moduleId == null) {
                continue;
            }
            results.push({
                moduleId,
                importedName: decl.name.getText(),
            });
            continue;
        }
        /**
         * One of:
         * - const { <foo: bar> } = require('mod');
         * - TODO: const { <foo: bar> } = require('mod').foo;
         */
        if (typescript_1.default.isBindingElement(decl)) {
            const variableDeclaration = closestAncestor(decl, typescript_1.default.SyntaxKind.VariableDeclaration);
            if (variableDeclaration == null) {
                continue;
            }
            const moduleId = resolveImportModuleId(variableDeclaration);
            if (moduleId == null) {
                continue;
            }
            results.push({
                moduleId,
                exportedName: (_d = (_c = decl.propertyName) === null || _c === void 0 ? void 0 : _c.getText()) !== null && _d !== void 0 ? _d : decl.name.getText(),
                importedName: decl.name.getText(),
            });
            continue;
        }
    }
    return results;
}
exports.resolveImportedName = resolveImportedName;
function resolveImportModuleId(node) {
    /**
     * One of:
     * - import x from 'mod';
     * - import {} from 'mod';
     * - import {} = require('mod');
     */
    if (typescript_1.default.isImportDeclaration(node)) {
        return resolveModuleSpecifier(node.moduleSpecifier);
    }
    /**
     * One of:
     * - import x = require("mod");
     * - import x = M.x;
     */
    if (typescript_1.default.isImportEqualsDeclaration(node)) {
        return resolveModuleReference(node.moduleReference);
    }
    if (typescript_1.default.isVariableDeclaration(node) && node.initializer !== undefined) {
        const requireCallExpression = findRequireCallExpression(node.initializer);
        const modIdExpr = requireCallExpression === null || requireCallExpression === void 0 ? void 0 : requireCallExpression.arguments[0];
        if (modIdExpr == null || !typescript_1.default.isStringLiteral(modIdExpr)) {
            return;
        }
        return modIdExpr.text;
    }
    return undefined;
}
function resolveModuleSpecifier(node) {
    // import ... from 'foo'
    if (typescript_1.default.isStringLiteral(node)) {
        return node.text;
    }
    // import {} = require('mod');
    if (typescript_1.default.isBinaryExpression(node) && isRequireCallExpression(node.right)) {
        if (typescript_1.default.isStringLiteral(node.right.arguments[0])) {
            return node.right.arguments[0].getText();
        }
    }
    return undefined;
}
function resolveModuleReference(node) {
    /**
     * One of:
     * - import foo = require('mod');
     */
    if (typescript_1.default.isExternalModuleReference(node) &&
        typescript_1.default.isStringLiteral(node.expression)) {
        return node.expression.text;
    }
    return undefined;
}
function closestAncestor(node, kind) {
    let parent = node.parent;
    while (parent != null) {
        if (parent.kind === kind) {
            return parent;
        }
        parent = parent.parent;
    }
    return undefined;
}
function isRequireCallExpression(node) {
    return (typescript_1.default.isCallExpression(node) &&
        typescript_1.default.isIdentifier(node.expression) &&
        node.expression.escapedText === 'require');
}
function findRequireCallExpression(node) {
    if (isRequireCallExpression(node)) {
        return node;
    }
    return typescript_1.default.forEachChild(node, child => {
        return findRequireCallExpression(child);
    });
}
//# sourceMappingURL=module.js.map