"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.debug = exports.toUnix = exports.getCodePositionInfo = exports.getSourceFileText = exports.tryCatch = exports.safeJsonParse = exports.getCodeOfNode = exports.USE = exports.chainBundle = exports.mixin = exports.any = exports.assert = exports.extend = void 0;
const typescript_1 = __importDefault(require("typescript"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
function extend(...args) {
    return args.reduce((previous, current) => {
        if (current == null) {
            return previous;
        }
        if (typeof current !== 'object') {
            return previous;
        }
        for (const [key, val] of Object.entries(current)) {
            if (val === undefined) {
                continue;
            }
            previous[key] = val;
        }
        return previous;
    }, {});
}
exports.extend = extend;
class AssertionFailure extends Error {
}
function assert(condition, message) {
    if (!condition) {
        throw new AssertionFailure(message !== null && message !== void 0 ? message : 'Assert Failed');
    }
}
exports.assert = assert;
function any(arr, match) {
    for (const item of arr) {
        if (match(item)) {
            return true;
        }
    }
    return false;
}
exports.any = any;
function mixin(lhs, rhs) {
    const it = {};
    Object.defineProperties(it, Object.getOwnPropertyDescriptors(lhs));
    Object.defineProperties(it, Object.getOwnPropertyDescriptors(rhs));
    return it;
}
exports.mixin = mixin;
function chainBundle(transformSourceFile) {
    return transformSourceFileOrBundle;
    function transformSourceFileOrBundle(node) {
        return node.kind === typescript_1.default.SyntaxKind.SourceFile
            ? transformSourceFile(node)
            : transformBundle(node);
    }
    function transformBundle(node) {
        return typescript_1.default.createBundle(node.sourceFiles.map(transformSourceFile), node.prepends);
    }
}
exports.chainBundle = chainBundle;
function USE(...condition) {
    condition;
}
exports.USE = USE;
function getCodeOfNode(node) {
    const printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed });
    return printer.printNode(typescript_1.default.EmitHint.Unspecified, node, typescript_1.default.createSourceFile('%%', '', typescript_1.default.ScriptTarget.ESNext));
}
exports.getCodeOfNode = getCodeOfNode;
function safeJsonParse(str) {
    try {
        return JSON.parse(str);
    }
    catch (_a) {
        /** ignore */
    }
    return undefined;
}
exports.safeJsonParse = safeJsonParse;
function tryCatch(fn, ...args) {
    try {
        const value = fn(...args);
        return { value };
    }
    catch (error) {
        return { error };
    }
}
exports.tryCatch = tryCatch;
const getSourceFileText = (nodeOrigin) => {
    let node = nodeOrigin;
    while (!typescript_1.default.isSourceFile(node) && node.parent) {
        node = node.parent;
    }
    return node.getText();
};
exports.getSourceFileText = getSourceFileText;
const getCodePositionInfo = (code, pos) => {
    var _a;
    try {
        const codeArr = code.substr(0, pos).split('\n');
        const ln = codeArr.length - 1;
        return {
            ln,
            col: ((_a = codeArr[ln]) === null || _a === void 0 ? void 0 : _a.length) || 0,
            index: pos,
        };
    }
    catch (_b) {
        /** ignore */
    }
    return { ln: 0, col: 0, index: 0 };
};
exports.getCodePositionInfo = getCodePositionInfo;
const toUnix = (p) => {
    if (process.platform === 'win32') {
        return p.split(path_1.default.sep).join(path_1.default.posix.sep);
    }
    return p;
};
exports.toUnix = toUnix;
exports.debug = util_1.debuglog('mwcc');
//# sourceMappingURL=util.js.map