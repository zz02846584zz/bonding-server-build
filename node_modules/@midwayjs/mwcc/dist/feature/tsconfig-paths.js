"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const module_1 = __importDefault(require("module"));
const path_1 = __importDefault(require("path"));
const util_1 = require("../util");
exports.default = {
    transform(ctx) {
        const compilerOptions = ctx.getCompilerOptions();
        if (typeof compilerOptions.paths !== 'object' ||
            Object.keys(compilerOptions.paths).length === 0) {
            return {};
        }
        return {
            // import xxx from '...'
            ImportDeclaration(node) {
                return updateImportExportDeclaration(node, ctx.getSourceFileName(node), compilerOptions);
            },
            // import xxx = require('xxx')
            ExternalModuleReference(node) {
                const sourceFilePath = ctx.getSourceFileName(node);
                const moduleSpecifier = getModuleSpecifier(node.expression);
                if (!moduleSpecifier) {
                    return node;
                }
                const { isAlias, target } = matchAliasPath(moduleSpecifier, sourceFilePath, compilerOptions);
                if (!isAlias) {
                    return node;
                }
                updateSourceFileResolvedModules(node.getSourceFile(), target, moduleSpecifier);
                return typescript_1.default.updateExternalModuleReference(node, typescript_1.default.createStringLiteral(target));
            },
            // type bar = typeof import("./bar").Bar;
            ImportType(node) {
                const sourceFilePath = ctx.getSourceFileName(node);
                const argument = node.argument;
                const moduleSpecifier = getModuleSpecifier(argument.literal);
                if (!moduleSpecifier) {
                    return node;
                }
                const { isAlias, target } = matchAliasPath(moduleSpecifier, sourceFilePath, compilerOptions);
                if (!isAlias) {
                    return node;
                }
                updateSourceFileResolvedModules(node.getSourceFile(), target, moduleSpecifier);
                // ts.updateImportTypeNode is invalid
                return Object.assign(node, {
                    argument: typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(target)),
                });
            },
            // export xxx from '...'
            ExportDeclaration(node) {
                return updateImportExportDeclaration(node, ctx.getSourceFileName(node), compilerOptions);
            },
            // import('xxx) or require('xxx')
            CallExpression(node) {
                if (!isRequire(node) && !isAsyncImport(node)) {
                    return node;
                }
                const sourceFilePath = ctx.getSourceFileName(node);
                const moduleSpecifier = getModuleSpecifier(node.arguments[0]);
                if (!moduleSpecifier) {
                    return node;
                }
                const { isAlias, target } = matchAliasPath(moduleSpecifier, sourceFilePath, compilerOptions);
                if (!isAlias) {
                    return node;
                }
                updateSourceFileResolvedModules(node.getSourceFile(), target, moduleSpecifier);
                return typescript_1.default.updateCall(node, node.expression, node.typeArguments, [
                    typescript_1.default.createStringLiteral(target),
                ]);
            },
        };
    },
};
function matchAliasPath(moduleSpecifier, sourceFilePath, compilerOptions) {
    const extensions = getExtensions(compilerOptions);
    const coreModules = getCoreModules(module_1.default === null || module_1.default === void 0 ? void 0 : module_1.default.builtinModules);
    if (coreModules[moduleSpecifier]) {
        return { isAlias: false, target: '' };
    }
    const { resolvedModule } = typescript_1.default.resolveModuleName(moduleSpecifier, sourceFilePath, compilerOptions, typescript_1.default.sys);
    if (!resolvedModule || resolvedModule.isExternalLibraryImport) {
        return { isAlias: false, target: '' };
    }
    const sourceFileDir = path_1.default.dirname(sourceFilePath);
    let target = util_1.toUnix(path_1.default.normalize(path_1.default.relative(sourceFileDir, resolvedModule.resolvedFileName)));
    if (resolvedModule.extension &&
        extensions.includes(resolvedModule.extension)) {
        target = target.slice(0, -resolvedModule.extension.length);
    }
    target = target[0] === '.' ? target : `./${target}`;
    return {
        isAlias: true,
        target,
    };
}
function getCoreModules(builtinModules) {
    // The 'module.builtinModules' is not supported until Node.js 9.3.0
    builtinModules = builtinModules || [
        'assert',
        'buffer',
        'child_process',
        'cluster',
        'crypto',
        'dgram',
        'dns',
        'domain',
        'events',
        'fs',
        'http',
        'https',
        'net',
        'os',
        'path',
        'punycode',
        'querystring',
        'readline',
        'stream',
        'string_decoder',
        'tls',
        'tty',
        'url',
        'util',
        'v8',
        'vm',
        'zlib',
    ];
    const coreModules = {};
    for (const module of builtinModules) {
        coreModules[module] = true;
    }
    return coreModules;
}
function getExtensions(compilerOptions) {
    const extensions = ['.ts', '.d.ts'];
    if (compilerOptions.allowJs) {
        extensions.push('.js');
    }
    if (compilerOptions.resolveJsonModule) {
        extensions.push('.json');
    }
    return extensions;
}
function isRequire(node) {
    return (typescript_1.default.isIdentifier(node.expression) &&
        node.expression.getText() === 'require' &&
        typescript_1.default.isStringLiteral(node.arguments[0]) &&
        node.arguments.length === 1);
}
function isAsyncImport(node) {
    return (node.expression.kind === typescript_1.default.SyntaxKind.ImportKeyword &&
        typescript_1.default.isStringLiteral(node.arguments[0]) &&
        node.arguments.length === 1);
}
function getModuleSpecifier(node) {
    if (node == null || !typescript_1.default.isStringLiteral(node)) {
        return undefined;
    }
    return node.text;
}
function updateImportExportDeclaration(node, sourceFilePath, compilerOptions) {
    if (node.moduleSpecifier == null) {
        return node;
    }
    const moduleSpecifier = getModuleSpecifier(node.moduleSpecifier);
    if (!moduleSpecifier) {
        return node;
    }
    const { isAlias, target } = matchAliasPath(moduleSpecifier, sourceFilePath, compilerOptions);
    if (!isAlias) {
        return node;
    }
    /**
     * Transforming ImportDeclaration or ExportDeclaration causes type specifiers to be output in js files
     * @see https://github.com/microsoft/TypeScript/issues/40603
     * @see https://github.com/microsoft/TypeScript/issues/31446
     */
    Object.assign(node, {
        moduleSpecifier: updateWithOriginal(typescript_1.default.factory.createStringLiteral(target), node.moduleSpecifier),
    });
    updateSourceFileResolvedModules(node.getSourceFile(), target, moduleSpecifier);
    return node;
}
function updateSourceFileResolvedModules(sourceFile, newModuleText, oldModuleText) {
    const its = typescript_1.default;
    const it = its.getResolvedModule(sourceFile, oldModuleText);
    its.setResolvedModule(sourceFile, newModuleText, it);
}
function updateWithOriginal(updated, original) {
    if (updated !== original) {
        typescript_1.default.setOriginalNode(updated, original);
        typescript_1.default.setTextRange(updated, original);
    }
    return updated;
}
//# sourceMappingURL=tsconfig-paths.js.map