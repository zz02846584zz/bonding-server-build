"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebControllerGenerator = void 0;
/**
 * wrap controller string to middleware function
 * @param controllerMapping like FooController.index
 * @param routeArgsInfo
 * @param routerResponseData
 */
const decorator_1 = require("@midwayjs/decorator");
const index_1 = require("../index");
const util = require("util");
const debug = util.debuglog('midway:debug');
class WebControllerGenerator {
    constructor(app) {
        this.app = app;
    }
    /**
     * wrap controller string to middleware function
     * @param routeInfo
     */
    generateKoaController(routeInfo) {
        return async (ctx, next) => {
            const args = [ctx, next];
            const controller = await ctx.requestContext.getAsync(routeInfo.id);
            // eslint-disable-next-line prefer-spread
            const result = await controller[routeInfo.method].apply(controller, args);
            if (result !== undefined) {
                ctx.body = result;
            }
            if (ctx.body === undefined && !ctx.response._explicitStatus) {
                ctx.body = undefined;
            }
            // implement response decorator
            if (Array.isArray(routeInfo.responseMetadata) &&
                routeInfo.responseMetadata.length) {
                for (const routerRes of routeInfo.responseMetadata) {
                    switch (routerRes.type) {
                        case decorator_1.WEB_RESPONSE_HTTP_CODE:
                            ctx.status = routerRes.code;
                            break;
                        case decorator_1.WEB_RESPONSE_HEADER:
                            for (const key in (routerRes === null || routerRes === void 0 ? void 0 : routerRes.setHeaders) || {}) {
                                ctx.set(key, routerRes.setHeaders[key]);
                            }
                            break;
                        case decorator_1.WEB_RESPONSE_CONTENT_TYPE:
                            ctx.type = routerRes.contentType;
                            break;
                        case decorator_1.WEB_RESPONSE_REDIRECT:
                            ctx.status = routerRes.code;
                            ctx.redirect(routerRes.url);
                            return;
                    }
                }
            }
        };
    }
    async loadMidwayController(globalPrefix, routerHandler) {
        var _a, _b;
        const collector = new index_1.WebRouterCollector('', {
            globalPrefix,
        });
        const routerTable = await collector.getRouterTable();
        const routerList = await collector.getRoutePriorityList();
        const applicationContext = this.app.getApplicationContext();
        const logger = this.app.getCoreLogger();
        const middlewareService = applicationContext.get(index_1.MidwayMiddlewareService);
        for (const routerInfo of routerList) {
            // bind controller first
            applicationContext.bindClass(routerInfo.routerModule);
            logger.debug(`Load Controller "${routerInfo.controllerId}", prefix=${routerInfo.prefix}`);
            debug(`[core]: Load Controller "${routerInfo.controllerId}", prefix=${routerInfo.prefix}`);
            // new router
            const newRouter = this.createRouter({
                prefix: routerInfo.prefix,
                ...routerInfo.routerOptions,
            });
            // add router middleware
            routerInfo.middleware = (_a = routerInfo.middleware) !== null && _a !== void 0 ? _a : [];
            if (routerInfo.middleware.length) {
                const routerMiddlewareFn = await middlewareService.compose(routerInfo.middleware, this.app);
                newRouter.use(routerMiddlewareFn);
            }
            // add route
            const routes = routerTable.get(routerInfo.prefix);
            for (const routeInfo of routes) {
                // get middleware
                const methodMiddlewares = [];
                routeInfo.middleware = (_b = routeInfo.middleware) !== null && _b !== void 0 ? _b : [];
                if (routeInfo.middleware.length) {
                    const routeMiddlewareFn = await middlewareService.compose(routeInfo.middleware, this.app);
                    methodMiddlewares.push(routeMiddlewareFn);
                }
                if (this.app.getFrameworkType() === decorator_1.MidwayFrameworkType.WEB_KOA) {
                    if (typeof routeInfo.url === 'string' && /\*$/.test(routeInfo.url)) {
                        routeInfo.url = routeInfo.url.replace('*', '(.*)');
                    }
                }
                const routerArgs = [
                    routeInfo.routerName,
                    routeInfo.url,
                    ...methodMiddlewares,
                    this.generateController(routeInfo),
                ];
                logger.debug(`Load Router "${routeInfo.requestMethod.toUpperCase()} ${routeInfo.url}"`);
                debug(`[core]: Load Router "${routeInfo.requestMethod.toUpperCase()} ${routeInfo.url}"`);
                // apply controller from request context
                // eslint-disable-next-line prefer-spread
                newRouter[routeInfo.requestMethod].apply(newRouter, routerArgs);
            }
            routerHandler && routerHandler(newRouter);
        }
    }
}
exports.WebControllerGenerator = WebControllerGenerator;
//# sourceMappingURL=webGenerator.js.map