"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebRouterCollector = void 0;
const decorator_1 = require("@midwayjs/decorator");
const util_1 = require("../util");
const container_1 = require("../context/container");
const fileDetector_1 = require("./fileDetector");
const util = require("util");
const error_1 = require("../error");
const debug = util.debuglog('midway:debug');
class WebRouterCollector {
    constructor(baseDir = '', options = {}) {
        this.isReady = false;
        this.routes = new Map();
        this.routesPriority = [];
        this.baseDir = baseDir;
        this.options = options;
    }
    async analyze() {
        if (this.baseDir) {
            const container = new container_1.MidwayContainer();
            container.setFileDetector(new fileDetector_1.DirectoryFileDetector({
                loadDir: this.baseDir,
            }));
            await container.ready();
        }
        const controllerModules = (0, decorator_1.listModule)(decorator_1.CONTROLLER_KEY);
        for (const module of controllerModules) {
            this.collectRoute(module);
        }
        if (this.options.includeFunctionRouter) {
            const fnModules = (0, decorator_1.listModule)(decorator_1.FUNC_KEY);
            for (const module of fnModules) {
                this.collectFunctionRoute(module);
            }
        }
        // filter empty prefix
        this.routesPriority = this.routesPriority.filter(item => {
            const prefixList = this.routes.get(item.prefix);
            if (prefixList.length > 0) {
                return true;
            }
            else {
                this.routes.delete(item.prefix);
                return false;
            }
        });
        // sort router
        for (const prefix of this.routes.keys()) {
            const routerInfo = this.routes.get(prefix);
            this.routes.set(prefix, this.sortRouter(routerInfo));
        }
        // sort prefix
        this.routesPriority = this.routesPriority.sort((routeA, routeB) => {
            return routeB.prefix.length - routeA.prefix.length;
        });
    }
    collectRoute(module, functionMeta = false) {
        var _a;
        const controllerId = (0, decorator_1.getProviderName)(module);
        debug(`[core]: Found Controller ${controllerId}.`);
        const id = (0, decorator_1.getProviderUUId)(module);
        const controllerOption = (0, decorator_1.getClassMetadata)(decorator_1.CONTROLLER_KEY, module);
        let priority;
        // implement middleware in controller
        const middleware = controllerOption.routerOptions.middleware;
        const controllerIgnoreGlobalPrefix = !!((_a = controllerOption.routerOptions) === null || _a === void 0 ? void 0 : _a.ignoreGlobalPrefix);
        let prefix = (0, util_1.joinURLPath)(this.options.globalPrefix, controllerOption.prefix || '/');
        const ignorePrefix = controllerOption.prefix || '/';
        // if controller set ignore global prefix, all router will be ignore too.
        if (controllerIgnoreGlobalPrefix) {
            prefix = ignorePrefix;
        }
        if (/\*/.test(prefix)) {
            throw new error_1.MidwayCommonError(`Router prefix ${prefix} can't set string with *`);
        }
        // set prefix
        if (!this.routes.has(prefix)) {
            this.routes.set(prefix, []);
            this.routesPriority.push({
                prefix,
                priority: prefix === '/' && priority === undefined ? -999 : 0,
                middleware,
                routerOptions: controllerOption.routerOptions,
                controllerId,
                routerModule: module,
            });
        }
        // set ignorePrefix
        if (!this.routes.has(ignorePrefix)) {
            this.routes.set(ignorePrefix, []);
            this.routesPriority.push({
                prefix: ignorePrefix,
                priority: ignorePrefix === '/' && priority === undefined ? -999 : 0,
                middleware,
                routerOptions: controllerOption.routerOptions,
                controllerId,
                routerModule: module,
            });
        }
        const webRouterInfo = (0, decorator_1.getClassMetadata)(decorator_1.WEB_ROUTER_KEY, module);
        if (webRouterInfo && typeof webRouterInfo[Symbol.iterator] === 'function') {
            for (const webRouter of webRouterInfo) {
                const routeArgsInfo = (0, decorator_1.getPropertyDataFromClass)(decorator_1.WEB_ROUTER_PARAM_KEY, module, webRouter.method) || [];
                const routerResponseData = (0, decorator_1.getPropertyMetadata)(decorator_1.WEB_RESPONSE_KEY, module, webRouter.method) || [];
                const data = {
                    id,
                    prefix: webRouter.ignoreGlobalPrefix ? ignorePrefix : prefix,
                    routerName: webRouter.routerName || '',
                    url: webRouter.path,
                    requestMethod: webRouter.requestMethod,
                    method: webRouter.method,
                    description: webRouter.description || '',
                    summary: webRouter.summary || '',
                    handlerName: `${controllerId}.${webRouter.method}`,
                    funcHandlerName: `${controllerId}.${webRouter.method}`,
                    controllerId,
                    middleware: webRouter.middleware || [],
                    controllerMiddleware: middleware || [],
                    requestMetadata: routeArgsInfo,
                    responseMetadata: routerResponseData,
                };
                if (functionMeta) {
                    // get function information
                    data.functionName = controllerId + '-' + webRouter.method;
                    data.functionTriggerName = decorator_1.ServerlessTriggerType.HTTP;
                    data.functionTriggerMetadata = {
                        path: (0, util_1.joinURLPath)(prefix, webRouter.path.toString()),
                        method: webRouter.requestMethod,
                    };
                    data.functionMetadata = {
                        functionName: data.functionName,
                    };
                }
                this.checkDuplicateAndPush(data.prefix, data);
            }
        }
    }
    collectFunctionRoute(module, functionMeta = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        // serverlessTrigger metadata
        const webRouterInfo = (0, decorator_1.getClassMetadata)(decorator_1.FUNC_KEY, module);
        const controllerId = (0, decorator_1.getProviderName)(module);
        const id = (0, decorator_1.getProviderUUId)(module);
        const prefix = '/';
        if (!this.routes.has(prefix)) {
            this.routes.set(prefix, []);
            this.routesPriority.push({
                prefix,
                priority: -999,
                middleware: [],
                routerOptions: {},
                controllerId,
                routerModule: module,
            });
        }
        for (const webRouter of webRouterInfo) {
            // 新的 @ServerlessTrigger 写法
            if ((_a = webRouter['metadata']) === null || _a === void 0 ? void 0 : _a['path']) {
                const routeArgsInfo = (0, decorator_1.getPropertyDataFromClass)(decorator_1.WEB_ROUTER_PARAM_KEY, module, webRouter['methodName']) || [];
                const routerResponseData = (0, decorator_1.getPropertyMetadata)(decorator_1.WEB_RESPONSE_KEY, module, webRouter['methodName']) || [];
                // 新 http/api gateway 函数
                const data = {
                    id,
                    prefix,
                    routerName: '',
                    url: webRouter['metadata']['path'],
                    requestMethod: (_c = (_b = webRouter['metadata']) === null || _b === void 0 ? void 0 : _b['method']) !== null && _c !== void 0 ? _c : 'get',
                    method: webRouter['methodName'],
                    description: '',
                    summary: '',
                    handlerName: `${controllerId}.${webRouter['methodName']}`,
                    funcHandlerName: `${controllerId}.${webRouter['methodName']}`,
                    controllerId,
                    middleware: ((_d = webRouter['metadata']) === null || _d === void 0 ? void 0 : _d['middleware']) || [],
                    controllerMiddleware: [],
                    requestMetadata: routeArgsInfo,
                    responseMetadata: routerResponseData,
                };
                if (functionMeta) {
                    const functionMeta = (0, decorator_1.getPropertyMetadata)(decorator_1.SERVERLESS_FUNC_KEY, module, webRouter['methodName']) || {};
                    const functionName = (_f = (_e = functionMeta['functionName']) !== null && _e !== void 0 ? _e : webRouter['functionName']) !== null && _f !== void 0 ? _f : createFunctionName(module, webRouter['methodName']);
                    data.functionName = functionName;
                    data.functionTriggerName = webRouter['type'];
                    data.functionTriggerMetadata = webRouter['metadata'];
                    data.functionMetadata = {
                        functionName,
                        ...functionMeta,
                    };
                }
                this.checkDuplicateAndPush(prefix, data);
            }
            else {
                if (functionMeta) {
                    const functionMeta = (0, decorator_1.getPropertyMetadata)(decorator_1.SERVERLESS_FUNC_KEY, module, webRouter['methodName']) || {};
                    const functionName = (_h = (_g = functionMeta['functionName']) !== null && _g !== void 0 ? _g : webRouter['functionName']) !== null && _h !== void 0 ? _h : createFunctionName(module, webRouter['methodName']);
                    // 其他类型的函数
                    this.checkDuplicateAndPush(prefix, {
                        id,
                        prefix,
                        routerName: '',
                        url: '',
                        requestMethod: '',
                        method: webRouter['methodName'],
                        description: '',
                        summary: '',
                        handlerName: `${controllerId}.${webRouter['methodName']}`,
                        funcHandlerName: `${controllerId}.${webRouter['methodName']}`,
                        controllerId,
                        middleware: ((_j = webRouter['metadata']) === null || _j === void 0 ? void 0 : _j['middleware']) || [],
                        controllerMiddleware: [],
                        requestMetadata: [],
                        responseMetadata: [],
                        functionName,
                        functionTriggerName: webRouter['type'],
                        functionTriggerMetadata: webRouter['metadata'],
                        functionMetadata: {
                            functionName,
                            ...functionMeta,
                        },
                    });
                }
            }
        }
    }
    sortRouter(urlMatchList) {
        // 1. 绝对路径规则优先级最高如 /ab/cb/e
        // 2. 星号只能出现最后且必须在/后面，如 /ab/cb/**
        // 3. 如果绝对路径和通配都能匹配一个路径时，绝对规则优先级高
        // 4. 有多个通配能匹配一个路径时，最长的规则匹配，如 /ab/** 和 /ab/cd/** 在匹配 /ab/cd/f 时命中 /ab/cd/**
        // 5. 如果 / 与 /* 都能匹配 / ,但 / 的优先级高于 /*
        return urlMatchList
            .map(item => {
            const urlString = item.url.toString();
            const weightArr = decorator_1.Types.isRegExp(item.url)
                ? urlString.split('\\/')
                : urlString.split('/');
            let weight = 0;
            // 权重，比如通配的不加权，非通配加权，防止通配出现在最前面
            for (const fragment of weightArr) {
                if (fragment === '' ||
                    fragment.includes(':') ||
                    fragment.includes('*')) {
                    weight += 0;
                }
                else {
                    weight += 1;
                }
            }
            let category = 2;
            const paramString = urlString.includes(':')
                ? urlString.replace(/:.+$/, '')
                : '';
            if (paramString) {
                category = 1;
            }
            if (urlString.includes('*')) {
                category = 0;
            }
            return {
                ...item,
                _pureRouter: urlString.replace(/\**$/, '').replace(/:\w+/, '123'),
                _level: urlString.split('/').length - 1,
                _paramString: paramString,
                _category: category,
                _weight: weight,
            };
        })
            .sort((handlerA, handlerB) => {
            // 不同一层级的对比
            if (handlerA._category !== handlerB._category) {
                return handlerB._category - handlerA._category;
            }
            // 不同权重
            if (handlerA._weight !== handlerB._weight) {
                return handlerB._weight - handlerA._weight;
            }
            // 不同长度
            if (handlerA._level === handlerB._level) {
                if (handlerB._pureRouter === handlerA._pureRouter) {
                    return (handlerA.url.toString().length - handlerB.url.toString().length);
                }
                return handlerB._pureRouter.length - handlerA._pureRouter.length;
            }
            return handlerB._level - handlerA._level;
        });
    }
    async getRoutePriorityList() {
        if (!this.isReady) {
            await this.analyze();
            this.isReady = true;
        }
        return this.routesPriority;
    }
    async getRouterTable() {
        if (!this.isReady) {
            await this.analyze();
            this.isReady = true;
        }
        return this.routes;
    }
    async getFlattenRouterTable() {
        if (!this.isReady) {
            await this.analyze();
            this.isReady = true;
        }
        let routeArr = [];
        for (const routerPriority of this.routesPriority) {
            routeArr = routeArr.concat(this.routes.get(routerPriority.prefix));
        }
        return routeArr;
    }
    checkDuplicateAndPush(prefix, routerInfo) {
        const prefixList = this.routes.get(prefix);
        const matched = prefixList.filter(item => {
            return (routerInfo.url &&
                routerInfo.requestMethod &&
                item.url === routerInfo.url &&
                item.requestMethod === routerInfo.requestMethod);
        });
        if (matched && matched.length) {
            throw new error_1.MidwayDuplicateRouteError(`${routerInfo.requestMethod} ${routerInfo.url}`, `${matched[0].handlerName}`, `${routerInfo.handlerName}`);
        }
        prefixList.push(routerInfo);
    }
}
exports.WebRouterCollector = WebRouterCollector;
function createFunctionName(target, functionName) {
    return (0, decorator_1.getProviderName)(target).replace(/[:#]/g, '-') + '-' + functionName;
}
//# sourceMappingURL=webRouterCollector.js.map