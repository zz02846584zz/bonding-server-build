"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isIncludeProperty = exports.wrapMiddleware = exports.pathMatching = exports.toPathMatch = exports.transformRequestObjectByType = exports.deprecatedOutput = exports.getCurrentDateString = exports.delegateTargetProperties = exports.delegateTargetMethod = exports.delegateTargetAllPrototypeMethod = exports.delegateTargetPrototypeMethod = exports.joinURLPath = exports.getUserHome = exports.parsePrefix = exports.safelyGet = exports.safeRequire = exports.getCurrentEnvironment = exports.isDevelopmentEnvironment = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const util_1 = require("util");
const transformer = require("class-transformer");
const pathToRegexp_1 = require("./pathToRegexp");
const error_1 = require("../error");
const debug = (0, util_1.debuglog)('midway:container:util');
/**
 * @since 2.0.0
 * @param env
 */
const isDevelopmentEnvironment = env => {
    return ['local', 'test', 'unittest'].includes(env);
};
exports.isDevelopmentEnvironment = isDevelopmentEnvironment;
/**
 * @since 2.0.0
 */
const getCurrentEnvironment = () => {
    return process.env['MIDWAY_SERVER_ENV'] || process.env['NODE_ENV'] || 'prod';
};
exports.getCurrentEnvironment = getCurrentEnvironment;
/**
 * @param p
 * @param enabledCache
 * @since 2.0.0
 */
const safeRequire = (p, enabledCache = true) => {
    if (p.startsWith(`.${path_1.sep}`) || p.startsWith(`..${path_1.sep}`)) {
        p = (0, path_1.resolve)((0, path_1.dirname)(module.parent.filename), p);
    }
    try {
        if (enabledCache) {
            return require(p);
        }
        else {
            const content = (0, fs_1.readFileSync)(p, {
                encoding: 'utf-8',
            });
            return JSON.parse(content);
        }
    }
    catch (err) {
        debug(`SafeRequire Warning, message = ${err.message}`);
        return undefined;
    }
};
exports.safeRequire = safeRequire;
/**
 *  safelyGet(['a','b'],{a: {b: 2}})  // => 2
 *  safelyGet(['a','b'],{c: {b: 2}})  // => undefined
 *  safelyGet(['a','1'],{a: {"1": 2}})  // => 2
 *  safelyGet(['a','1'],{a: {b: 2}})  // => undefined
 *  safelyGet('a.b',{a: {b: 2}})  // => 2
 *  safelyGet('a.b',{c: {b: 2}})  // => undefined
 *  @since 2.0.0
 */
function safelyGet(list, obj) {
    if (arguments.length === 1) {
        return (_obj) => safelyGet(list, _obj);
    }
    if (typeof obj === 'undefined' || typeof obj !== 'object' || obj === null) {
        return void 0;
    }
    const pathArrValue = typeof list === 'string' ? list.split('.') : list;
    let willReturn = obj;
    for (const key of pathArrValue) {
        if (typeof willReturn === 'undefined' || willReturn === null) {
            return void 0;
        }
        else if (typeof willReturn !== 'object') {
            return void 0;
        }
        willReturn = willReturn[key];
    }
    return willReturn;
}
exports.safelyGet = safelyGet;
/**
 * 剔除 @ 符号
 * @param provideId provideId
 * @since 2.0.0
 */
function parsePrefix(provideId) {
    if (provideId.includes('@')) {
        return provideId.slice(1);
    }
    return provideId;
}
exports.parsePrefix = parsePrefix;
function getUserHome() {
    return process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
}
exports.getUserHome = getUserHome;
function joinURLPath(...strArray) {
    strArray = strArray.filter(item => !!item);
    if (strArray.length === 0) {
        return '';
    }
    let p = path_1.posix.join(...strArray);
    p = p.replace(/\/+$/, '');
    if (!/^\//.test(p)) {
        p = '/' + p;
    }
    return p;
}
exports.joinURLPath = joinURLPath;
/**
 * 代理目标所有的原型方法，不包括构造器和内部隐藏方法
 * @param derivedCtor
 * @param constructors
 * @param otherMethods
 * @since 2.0.0
 */
function delegateTargetPrototypeMethod(derivedCtor, constructors, otherMethods) {
    constructors.forEach(baseCtor => {
        if (baseCtor.prototype) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
                if (name !== 'constructor' &&
                    !/^_/.test(name) &&
                    !derivedCtor.prototype[name]) {
                    derivedCtor.prototype[name] = function (...args) {
                        return this.instance[name](...args);
                    };
                }
            });
        }
    });
    if (otherMethods) {
        delegateTargetMethod(derivedCtor, otherMethods);
    }
}
exports.delegateTargetPrototypeMethod = delegateTargetPrototypeMethod;
/**
 * 代理目标所有的原型方法，包括原型链，不包括构造器和内部隐藏方法
 * @param derivedCtor
 * @param constructor
 * @since 3.0.0
 */
function delegateTargetAllPrototypeMethod(derivedCtor, constructor) {
    do {
        delegateTargetPrototypeMethod(derivedCtor, [constructor]);
        constructor = Object.getPrototypeOf(constructor);
    } while (constructor);
}
exports.delegateTargetAllPrototypeMethod = delegateTargetAllPrototypeMethod;
/**
 * 代理目标原型上的特定方法
 * @param derivedCtor
 * @param methods
 * @since 2.0.0
 */
function delegateTargetMethod(derivedCtor, methods) {
    methods.forEach(name => {
        derivedCtor.prototype[name] = function (...args) {
            return this.instance[name](...args);
        };
    });
}
exports.delegateTargetMethod = delegateTargetMethod;
/**
 * 代理目标原型属性
 * @param derivedCtor
 * @param properties
 * @since 2.0.0
 */
function delegateTargetProperties(derivedCtor, properties) {
    properties.forEach(name => {
        Object.defineProperty(derivedCtor.prototype, name, {
            get() {
                return this.instance[name];
            },
        });
    });
}
exports.delegateTargetProperties = delegateTargetProperties;
/**
 * 获取当前的时间戳
 * @since 2.0.0
 * @param timestamp
 */
const getCurrentDateString = (timestamp = Date.now()) => {
    const d = new Date(timestamp);
    return `${d.getFullYear()}-${(d.getMonth() + 1)
        .toString()
        .padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
};
exports.getCurrentDateString = getCurrentDateString;
/**
 *
 * @param message
 * @since 3.0.0
 */
const deprecatedOutput = (message) => {
    console.warn('DeprecationWarning: ' + message);
};
exports.deprecatedOutput = deprecatedOutput;
/**
 * transform request object to definition type
 *
 * @param originValue
 * @param targetType
 * @since 3.0.0
 */
const transformRequestObjectByType = (originValue, targetType) => {
    if (targetType === undefined ||
        targetType === null ||
        targetType === Object ||
        typeof originValue === 'undefined') {
        return originValue;
    }
    switch (targetType) {
        case Number:
            return Number(originValue);
        case String:
            return String(originValue);
        case Boolean:
            if (originValue === '0' || originValue === 'false') {
                return false;
            }
            return Boolean(originValue);
        default:
            if (originValue instanceof targetType) {
                return originValue;
            }
            else {
                const transformToInstance = transformer['plainToClass'] || transformer['plainToInstance'];
                return transformToInstance(targetType, originValue);
            }
    }
};
exports.transformRequestObjectByType = transformRequestObjectByType;
function toPathMatch(pattern) {
    if (typeof pattern === 'boolean') {
        return ctx => pattern;
    }
    if (typeof pattern === 'string') {
        const reg = (0, pathToRegexp_1.pathToRegexp)(pattern, [], { end: false });
        if (reg.global)
            reg.lastIndex = 0;
        return ctx => reg.test(ctx.path);
    }
    if (pattern instanceof RegExp) {
        return ctx => {
            if (pattern.global)
                pattern.lastIndex = 0;
            return pattern.test(ctx.path);
        };
    }
    if (typeof pattern === 'function')
        return pattern;
    if (Array.isArray(pattern)) {
        const matchs = pattern.map(item => toPathMatch(item));
        return ctx => matchs.some(match => match(ctx));
    }
    throw new error_1.MidwayCommonError('match/ignore pattern must be RegExp, Array or String, but got ' + pattern);
}
exports.toPathMatch = toPathMatch;
function pathMatching(options) {
    options = options || {};
    if (options.match && options.ignore)
        throw new error_1.MidwayCommonError('options.match and options.ignore can not both present');
    if (!options.match && !options.ignore)
        return () => true;
    const matchFn = options.match
        ? toPathMatch(options.match)
        : toPathMatch(options.ignore);
    return function pathMatch(ctx) {
        const matched = matchFn(ctx);
        return options.match ? matched : !matched;
    };
}
exports.pathMatching = pathMatching;
/**
 * wrap function middleware with match and ignore
 * @param mw
 * @param options
 */
function wrapMiddleware(mw, options) {
    // support options.enable
    if (options.enable === false)
        return null;
    // support options.match and options.ignore
    if (!options.match && !options.ignore)
        return mw;
    const match = pathMatching(options);
    const fn = (ctx, next) => {
        if (!match(ctx))
            return next();
        return mw(ctx, next);
    };
    fn._name = mw._name + 'middlewareWrapper';
    return fn;
}
exports.wrapMiddleware = wrapMiddleware;
function isOwnPropertyWritable(obj, prop) {
    if (obj == null)
        return false;
    const type = typeof obj;
    if (type !== 'object' && type !== 'function')
        return false;
    return !!Object.getOwnPropertyDescriptor(obj, prop);
}
function isIncludeProperty(obj, prop) {
    while (obj) {
        if (isOwnPropertyWritable(obj, prop))
            return true;
        obj = Object.getPrototypeOf(obj);
    }
    return false;
}
exports.isIncludeProperty = isIncludeProperty;
//# sourceMappingURL=index.js.map