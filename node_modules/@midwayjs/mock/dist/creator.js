"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLightApp = exports.createFunctionApp = exports.close = exports.createApp = exports.create = void 0;
const core_1 = require("@midwayjs/core");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const decorator_1 = require("@midwayjs/decorator");
const logger_1 = require("@midwayjs/logger");
const utils_1 = require("./utils");
const util_1 = require("util");
const fs_1 = require("fs");
const debug = (0, util_1.debuglog)('midway:debug');
process.setMaxListeners(0);
async function create(appDir = process.cwd(), options, customFramework) {
    debug(`[mock]: Create app, appDir="${appDir}"`);
    process.env.MIDWAY_TS_MODE = 'true';
    if (appDir) {
        // 处理测试的 fixtures
        if (!(0, path_1.isAbsolute)(appDir)) {
            appDir = (0, path_1.join)(process.cwd(), 'test', 'fixtures', appDir);
        }
        if (!(0, fs_1.existsSync)(appDir)) {
            throw new core_1.MidwayCommonError(`Path "${appDir}" not exists, please check it.`);
        }
    }
    (0, logger_1.clearAllLoggers)();
    options = options || {};
    if (options.baseDir) {
        (0, core_1.safeRequire)((0, path_1.join)(`${options.baseDir}`, 'interface'));
    }
    else if (appDir) {
        options.baseDir = `${appDir}/src`;
        (0, core_1.safeRequire)((0, path_1.join)(`${options.baseDir}`, 'interface'));
    }
    if (!options.imports && customFramework) {
        options.imports = (0, utils_1.transformFrameworkToConfiguration)(customFramework);
    }
    if (customFramework === null || customFramework === void 0 ? void 0 : customFramework['Configuration']) {
        options.imports = customFramework;
        customFramework = customFramework['Framework'];
    }
    const container = new core_1.MidwayContainer();
    const bindModuleMap = new WeakMap();
    // 这里设置是因为在 midway 单测中会不断的复用装饰器元信息，又不能清理缓存，所以在这里做一些过滤
    container.onBeforeBind(target => {
        bindModuleMap.set(target, true);
    });
    const originMethod = container.listModule;
    container.listModule = key => {
        const modules = originMethod.call(container, key);
        if (key === decorator_1.CONFIGURATION_KEY) {
            return modules;
        }
        return modules.filter((module) => {
            var _a;
            if (bindModuleMap.has(module)) {
                return true;
            }
            else {
                debug('[mock] Filter "%o" module without binding when list module %s.', (_a = module.name) !== null && _a !== void 0 ? _a : module, key);
                return false;
            }
        });
    };
    options.applicationContext = container;
    await (0, core_1.initializeGlobalApplicationContext)({
        ...options,
        appDir,
        imports: []
            .concat(options.imports)
            .concat(options.baseDir
            ? (0, core_1.safeRequire)((0, path_1.join)(options.baseDir, 'configuration'))
            : []),
    });
    if (customFramework) {
        return container.getAsync(customFramework);
    }
    else {
        const frameworkService = await container.getAsync(core_1.MidwayFrameworkService);
        return frameworkService.getMainFramework();
    }
}
exports.create = create;
async function createApp(baseDir = process.cwd(), options, customFramework) {
    const framework = await create(baseDir, options, customFramework);
    return framework.getApplication();
}
exports.createApp = createApp;
async function close(app, options) {
    if (!app)
        return;
    debug(`[mock]: Closing app, appDir=${app.getAppDir()}`);
    options = options || {};
    await (0, core_1.destroyGlobalApplicationContext)(app.getApplicationContext());
    if ((0, utils_1.isTestEnvironment)()) {
        // clean first
        if (options.cleanLogsDir && !(0, utils_1.isWin32)()) {
            await (0, fs_extra_1.remove)((0, path_1.join)(app.getAppDir(), 'logs'));
        }
        if (core_1.MidwayFrameworkType.WEB === app.getFrameworkType()) {
            if (options.cleanTempDir && !(0, utils_1.isWin32)()) {
                await (0, fs_extra_1.remove)((0, path_1.join)(app.getAppDir(), 'run'));
            }
        }
        if (options.sleep > 0) {
            await (0, decorator_1.sleep)(options.sleep);
        }
        else {
            await (0, decorator_1.sleep)(50);
        }
    }
}
exports.close = close;
async function createFunctionApp(baseDir = process.cwd(), options, customFrameworkModule) {
    const customFramework = customFrameworkModule !== null && customFrameworkModule !== void 0 ? customFrameworkModule : (0, utils_1.findFirstExistModule)([
        process.env.MIDWAY_SERVERLESS_APP_NAME,
        '@ali/serverless-app',
        '@midwayjs/serverless-app',
    ]);
    const serverlessModule = (0, utils_1.transformFrameworkToConfiguration)(customFramework);
    if (serverlessModule) {
        if (options && options.imports) {
            options.imports.unshift(serverlessModule);
        }
        else {
            options = options || {};
            options.imports = [serverlessModule];
        }
    }
    const framework = await createApp(baseDir, options);
    const appCtx = framework.getApplicationContext();
    const appManager = appCtx.get(core_1.MidwayApplicationManager);
    return appManager.getApplication(core_1.MidwayFrameworkType.SERVERLESS_APP);
}
exports.createFunctionApp = createFunctionApp;
/**
 * 一个全量的空框架
 */
class LightFramework extends core_1.BaseFramework {
    getFrameworkType() {
        return core_1.MidwayFrameworkType.LIGHT;
    }
    async run() { }
    async applicationInitialize(options) {
        this.app = {};
        this.defineApplicationProperties();
    }
    configure() {
        return {};
    }
    getFrameworkName() {
        return 'lightFramework';
    }
}
/**
 * Create a real project but not ready or a virtual project
 * @param baseDir
 * @param options
 */
async function createLightApp(baseDir = '', options = {}) {
    var _a;
    (0, decorator_1.Framework)()(LightFramework);
    options.globalConfig = Object.assign({
        midwayLogger: {
            default: {
                disableFile: true,
                disableError: true,
            },
        },
    }, (_a = options.globalConfig) !== null && _a !== void 0 ? _a : {});
    return createApp(baseDir, {
        ...options,
        imports: [(0, utils_1.transformFrameworkToConfiguration)(LightFramework)].concat(options === null || options === void 0 ? void 0 : options.imports),
    });
}
exports.createLightApp = createLightApp;
//# sourceMappingURL=creator.js.map