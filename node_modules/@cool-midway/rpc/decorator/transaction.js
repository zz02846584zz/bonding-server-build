"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoolRpcTransaction = void 0;
const typeorm_1 = require("typeorm");
const uuid_1 = require("uuid");
const core_1 = require("@cool-midway/core");
function CoolRpcTransaction(option) {
    return (target, propertyKey, descriptor) => {
        const method = descriptor.value;
        descriptor.value = async function (...args) {
            let isCaller = false;
            let rpcTransactionId;
            if (args[0]) {
                isCaller = false;
                rpcTransactionId = args[0].rpcTransactionId;
            }
            // 如果没有事务ID，手动创建
            if (!rpcTransactionId) {
                isCaller = true;
                rpcTransactionId = uuid_1.v1();
            }
            let data;
            const connection = typeorm_1.getConnection((option === null || option === void 0 ? void 0 : option.connectionName) || 'default');
            const queryRunner = connection.createQueryRunner();
            // 使用我们的新queryRunner建立真正的数据库连
            await queryRunner.connect();
            if (option && option.isolation) {
                await queryRunner.startTransaction(option.isolation);
            }
            else {
                await queryRunner.startTransaction();
            }
            try {
                global['moleculer.transactions'][rpcTransactionId] = queryRunner;
                // 半小时后清除
                setTimeout(() => {
                    global['moleculer.transactions'][rpcTransactionId].release();
                    delete global['moleculer.transactions'][rpcTransactionId];
                }, 1800 * 1000);
                data = await method.apply(this, [
                    ...args,
                    rpcTransactionId,
                    queryRunner,
                ]);
                if (isCaller) {
                    global['moleculer:broker'].broadcast('moleculer.transaction', {
                        rpcTransactionId,
                        commit: true,
                    });
                }
                //await queryRunner.commitTransaction();
            }
            catch (error) {
                //await queryRunner.rollbackTransaction();
                if (isCaller) {
                    global['moleculer:broker'].broadcast('moleculer.transaction', {
                        rpcTransactionId,
                        commit: false,
                    });
                }
                throw new core_1.CoolCommException(error.message);
            }
            return data;
        };
        return descriptor;
    };
}
exports.CoolRpcTransaction = CoolRpcTransaction;
//# sourceMappingURL=transaction.js.map