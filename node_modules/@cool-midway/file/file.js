"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoolFile = void 0;
const decorator_1 = require("@midwayjs/decorator");
const interface_1 = require("./interface");
const core_1 = require("@cool-midway/core");
const moment = require("moment");
const uuid_1 = require("uuid");
const path = require("path");
const fs = require("fs");
const _ = require("lodash");
const OSS = require("ali-oss");
const crypto = require("crypto");
const STS = require("qcloud-cos-sts");
const download = require("download");
const COS = require("cos-nodejs-sdk-v5");
const QINIU = require("qiniu");
/**
 * 文件上传
 */
let CoolFile = class CoolFile {
    async init() {
        const filePath = path.join(this.app.getBaseDir(), '..', 'public');
        const uploadsPath = path.join(filePath, 'uploads');
        const tempPath = path.join(filePath, 'temp');
        if (!fs.existsSync(uploadsPath)) {
            fs.mkdirSync(uploadsPath);
        }
        if (!fs.existsSync(tempPath)) {
            fs.mkdirSync(tempPath);
        }
        const { mode, oss, cos, qiniu } = this.config;
        if (mode == interface_1.MODETYPE.CLOUD) {
            if (oss) {
                const { accessKeyId, accessKeySecret, bucket, endpoint } = this.config.oss;
                this.client = new OSS({
                    region: endpoint.split('.')[0],
                    accessKeyId,
                    accessKeySecret,
                    bucket,
                });
            }
            if (cos) {
                const { accessKeyId, accessKeySecret } = this.config.cos;
                this.client = new COS({
                    SecretId: accessKeyId,
                    SecretKey: accessKeySecret,
                });
            }
            if (qiniu) {
                const { accessKeyId, accessKeySecret } = this.config.qiniu;
                this.client = new QINIU.auth.digest.Mac(accessKeyId, accessKeySecret);
            }
        }
    }
    /**
     * 上传模式
     * @returns 上传模式
     */
    async getMode() {
        const { mode, oss, cos, qiniu } = this.config;
        if (mode == interface_1.MODETYPE.LOCAL) {
            return {
                mode: interface_1.MODETYPE.LOCAL,
                type: interface_1.MODETYPE.LOCAL,
            };
        }
        if (oss) {
            return {
                mode: interface_1.MODETYPE.CLOUD,
                type: interface_1.CLOUDTYPE.OSS,
            };
        }
        if (cos) {
            return {
                mode: interface_1.MODETYPE.CLOUD,
                type: interface_1.CLOUDTYPE.COS,
            };
        }
        if (qiniu) {
            return {
                mode: interface_1.MODETYPE.CLOUD,
                type: interface_1.CLOUDTYPE.QINIU,
            };
        }
    }
    /**
     * 获得原始操作对象
     * @returns
     */
    getMetaFileObj() {
        return this.client;
    }
    /**
     * 下载并上传
     * @param url
     */
    async downAndUpload(url) {
        const { mode, oss, cos, qiniu, domain } = this.config;
        let extend = '';
        if (url.includes('.')) {
            const urlArr = url.split('.');
            extend = '.' + urlArr[urlArr.length - 1];
        }
        const data = await download(url);
        const isCloud = mode == interface_1.MODETYPE.CLOUD;
        // 创建文件夹
        const dirPath = path.join(this.app.getBaseDir(), '..', `public/${isCloud ? 'temp' : 'uploads'}/${moment().format('YYYYMMDD')}`);
        if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath);
        }
        const uuidStr = uuid_1.v1();
        const name = `uploads/${moment().format('YYYYMMDD')}/${uuidStr}${extend}`;
        if (isCloud) {
            if (oss) {
                const ossClient = this.getMetaFileObj();
                return (await ossClient.put(name, data)).url;
            }
            if (cos) {
                const cosClient = this.getMetaFileObj();
                await cosClient.putObject({
                    Bucket: cos.bucket,
                    Region: cos.region,
                    Key: name,
                    Body: data,
                });
                return cos.publicDomain + '/' + name;
            }
            if (qiniu) {
                let uploadToken = (await this.qiniu())['token'];
                const formUploader = new QINIU.form_up.FormUploader();
                const putExtra = new QINIU.form_up.PutExtra();
                return new Promise((resolve, reject) => {
                    formUploader.put(uploadToken, name, data, putExtra, (respErr, respBody, respInfo) => {
                        if (respErr) {
                            throw respErr;
                        }
                        if (respInfo.statusCode == 200) {
                            resolve(qiniu.publicDomain + '/' + name);
                        }
                    });
                });
            }
        }
        else {
            fs.writeFileSync(`${dirPath}/${uuidStr}${extend}`, data);
            return `${domain}/public/${name}`;
        }
    }
    /**
     * 上传文件
     * @param ctx
     */
    async upload(ctx) {
        const { mode, oss, cos, qiniu } = this.config;
        if (mode == interface_1.MODETYPE.LOCAL) {
            return await this.local(ctx);
        }
        if (mode == interface_1.MODETYPE.CLOUD) {
            if (oss) {
                return await this.oss(ctx);
            }
            if (cos) {
                return await this.cos(ctx);
            }
            if (qiniu) {
                return await this.qiniu(ctx);
            }
        }
    }
    /**
     * 七牛上传
     * @param ctx
     * @returns
     */
    async qiniu(ctx) {
        const { bucket, publicDomain, region } = this.config.qiniu;
        let options = {
            scope: bucket,
        };
        const putPolicy = new QINIU.rs.PutPolicy(options);
        const uploadToken = putPolicy.uploadToken(this.client);
        return new Promise((resolve, reject) => {
            resolve({
                uploadUrl: `https://upload-${region}.qiniup.com/`,
                publicDomain,
                token: uploadToken,
                fileKey: 'file',
            });
        });
    }
    /**
     * OSS 文件上传
     * @param ctx
     */
    async oss(ctx) {
        const { accessKeyId, accessKeySecret, bucket, endpoint } = this.config.oss;
        const oss = {
            bucket,
            region: endpoint.split('.')[0],
            accessKeyId,
            accessKeySecret,
            expAfter: 300000,
            maxSize: 1048576000, // 文件最大的 size
        };
        const host = `https://${bucket}.${endpoint}`;
        const expireTime = new Date().getTime() + oss.expAfter;
        const expiration = new Date(expireTime).toISOString();
        const policyString = JSON.stringify({
            expiration,
            conditions: [
                ['content-length-range', 0, 200 * 1024 * 1024], // 设置上传文件的大小限制,200mb
            ],
        });
        const policy = Buffer.from(policyString).toString('base64');
        const signature = crypto
            .createHmac('sha1', oss.accessKeySecret)
            .update(policy)
            .digest('base64');
        return {
            signature,
            policy,
            host,
            OSSAccessKeyId: accessKeyId,
            success_action_status: 200,
        };
    }
    /**
     * COS 文件上传
     * @param ctx
     */
    async cos(ctx) {
        const { accessKeyId, accessKeySecret, bucket, region, publicDomain } = this.config.cos;
        // 配置参数
        let config = {
            secretId: accessKeyId,
            secretKey: accessKeySecret,
            durationSeconds: 1800,
            bucket: bucket,
            region: region,
            // 允许操作（上传）的对象前缀，可以根据自己网站的用户登录态判断允许上传的目录，例子： user1/* 或者 * 或者a.jpg
            // 请注意当使用 * 时，可能存在安全风险，详情请参阅：https://cloud.tencent.com/document/product/436/40265
            allowPrefix: '_ALLOW_DIR_/*',
            // 密钥的权限列表
            allowActions: [
                // 所有 action 请看文档 https://cloud.tencent.com/document/product/436/31923
                // 简单上传
                'name/cos:PutObject',
                'name/cos:PostObject',
                // 分片上传
                'name/cos:InitiateMultipartUpload',
                'name/cos:ListMultipartUploads',
                'name/cos:ListParts',
                'name/cos:UploadPart',
                'name/cos:CompleteMultipartUpload',
            ],
        };
        // 获取临时密钥
        let LongBucketName = config.bucket;
        let ShortBucketName = LongBucketName.substr(0, LongBucketName.lastIndexOf('-'));
        let AppId = LongBucketName.substr(LongBucketName.lastIndexOf('-') + 1);
        let policy = {
            version: '2.0',
            statement: [
                {
                    action: config.allowActions,
                    effect: 'allow',
                    resource: [
                        'qcs::cos:' +
                            config.region +
                            ':uid/' +
                            AppId +
                            ':prefix//' +
                            AppId +
                            '/' +
                            ShortBucketName +
                            '/' +
                            config.allowPrefix,
                    ],
                },
            ],
        };
        return new Promise((resolve, reject) => {
            STS.getCredential({
                secretId: config.secretId,
                secretKey: config.secretKey,
                durationSeconds: config.durationSeconds,
                policy: policy,
            }, (err, tempKeys) => {
                if (err) {
                    reject(err);
                }
                if (tempKeys) {
                    tempKeys.startTime = Math.round(Date.now() / 1000);
                }
                resolve({
                    ...tempKeys,
                    url: publicDomain,
                });
            });
        });
    }
    /**
     * 本地上传
     * @param ctx
     * @returns
     */
    async local(ctx) {
        try {
            const { key } = ctx.fields;
            if (_.isEmpty(ctx.files)) {
                throw new core_1.CoolCommException('上传文件为空');
            }
            const file = ctx.files[0];
            const name = moment().format('YYYYMMDD') + '/' + key;
            const target = path.join(this.app.getBaseDir(), '..', `public/uploads/${name}`);
            const dirPath = path.join(this.app.getBaseDir(), '..', `public/uploads/${moment().format('YYYYMMDD')}`);
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath);
            }
            const data = fs.readFileSync(file.data);
            fs.writeFileSync(target, data);
            return this.config.domain + '/public/uploads/' + name;
        }
        catch (err) {
            this.coreLogger.error(err);
            throw new core_1.CoolCommException('上传失败');
        }
    }
};
__decorate([
    decorator_1.Config('cool.file'),
    __metadata("design:type", Object)
], CoolFile.prototype, "config", void 0);
__decorate([
    decorator_1.Logger(),
    __metadata("design:type", Object)
], CoolFile.prototype, "coreLogger", void 0);
__decorate([
    decorator_1.App(),
    __metadata("design:type", Object)
], CoolFile.prototype, "app", void 0);
__decorate([
    decorator_1.Init(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], CoolFile.prototype, "init", null);
CoolFile = __decorate([
    decorator_1.Provide(),
    decorator_1.Scope(decorator_1.ScopeEnum.Singleton)
], CoolFile);
exports.CoolFile = CoolFile;
//# sourceMappingURL=file.js.map